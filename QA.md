---

## 12. Who generates the idempotency key in real-world systems (frontend or backend), and how does it work?

**Answer:**

- In real-world projects like Agoda, MakeMyTrip, or Airbnb, the idempotency key is usually generated by the **frontend (client)** before making the booking API call.
- The frontend sends this key as a header or in the request body to the backend.
- The backend uses this key to check if a booking with the same idempotency key already exists:
  - If yes, it returns the existing booking (no duplicate).
  - If no, it creates a new booking and stores the key.

**Why?**
- If the backend generates the key, the client won’t know it in advance, so it can’t retry safely.
- If the client generates and sends the key, retries (due to network issues, double-clicks, etc.) will always be recognized as the same request.

**When is the key sent?**
- The frontend generates and sends the idempotency key with the initial booking request.
- The backend returns the same key (and booking info) in the response.
- For confirmation, the frontend uses the same key to confirm the booking.

**Summary:**
- In production, the frontend should generate and send the idempotency key for true idempotency and safe retries.
- The backend should always check for this key at the start of the booking process.
# Booking Service Q&A

---

## 1. How is Redis locking used in `createBookingService`?

**Answer:**  
Redis locking (using Redlock) is used to prevent multiple users from booking the same hotel (or its rooms) at the same time. When a booking request comes in, the backend tries to acquire a lock on a resource (here, the hotel) for a short period (e.g., 50,000 ms). If the lock is acquired, the booking process continues; otherwise, it waits or fails, preventing double bookings.

---

## 2. Why are we locking by hotel ID and not room ID? Should we use room ID instead?

**Answer:**  
Locking by hotel ID means only one booking process can happen for the entire hotel at a time. This is simple but can block too many users if the hotel has many rooms.  
**Better approach:** Lock by room ID or room category ID, so only the specific room (or type) being booked is locked. This allows multiple bookings for different rooms at the same hotel simultaneously.

---

## 3. How does the Redis lock work in the backend?

**Answer:**  
When a booking request is made, the backend tries to acquire a lock in Redis for the hotel (or room). If successful, it proceeds with booking. If not, it means another booking is in progress, and the request may fail or wait.  
**Note:** The frontend does not check Redis directly. The backend handles locking and returns an error if the lock can't be acquired.

---

## 4. Does the frontend check Redis or the lock status?

**Answer:**  
No, the frontend does not interact with Redis or check the lock. It simply calls the booking API. If the backend cannot acquire the lock (because another booking is in progress), it returns an error, and the frontend can show a message to the user.

---

## 5. Why do we use an idempotency key in booking?

**Answer:**  
An idempotency key ensures that if the same booking request is sent multiple times (e.g., due to network retries), only one booking is created.

- The backend generates and stores this key with the booking.
- If a request with the same key comes again, it knows not to create a duplicate booking.

---

## 6. Why do we finalize (release) the idempotency key after confirming the booking?

**Answer:**  
Finalizing the idempotency key marks the booking process as complete.

- This prevents further changes or duplicate confirmations for the same booking.
- It helps maintain data consistency and prevents accidental double bookings.

---

## 7. How does the idempotency key work from start to end in our booking process?

**Answer:**

- When a booking is created, a new idempotency key is generated and stored in the database, linked to the booking.
- If the same booking request (with the same idempotency key) is received again, the backend checks if this key already exists and is finalized.
- If it exists and is finalized, it does not create a duplicate booking and returns the existing booking.
- This check and logic are handled in the repository and service layer, especially in the `getIdempotencyKeyWithLock` and `finalizeIdempotencyKey` functions.
- In the `confirmBookingService`, the code checks if the idempotency key is already finalized before confirming the booking, preventing duplicate confirmations.

---

## 8. Where is the code that checks for duplicate bookings using the idempotency key?

**Answer:**

- The check happens in the `confirmBookingService` function, where it calls `getIdempotencyKeyWithLock` to fetch the idempotency key and booking.
- If the key is already finalized, it throws an error and does not proceed, preventing duplicate actions.
- The logic for creating, checking, and finalizing the idempotency key is in the `booking.repository.ts` file (functions: `createIdempotencyKey`, `getIdempotencyKeyWithLock`, `finalizeIdempotencyKey`).

---

## 9. Summary of the flow:

1. User requests a booking.
2. Backend tries to acquire a Redis lock (on hotel or room).
3. If lock acquired, booking process continues.
4. An idempotency key is generated and stored.
5. Booking is created and rooms are assigned.
6. On confirmation, the idempotency key is finalized.
7. If lock not acquired, backend returns an error (frontend can show "please try again" message).
8. If the same idempotency key is used again, backend checks and prevents duplicate bookings.

---

## 10. Does the idempotency key prevent duplicate calls to `createBookingService`, or only duplicate confirmations?

**Answer:**

- The idempotency key logic in your code (as shown) is mainly checked during the confirmation step (`confirmBookingService`), not during the initial booking creation (`createBookingService`).
- In `createBookingService`, the only protection against duplicate bookings is the Redis lock (Redlock) on the hotel (or room). This means:
  - If two requests for the same hotel/room come in at the exact same time, only one will get the lock and proceed; the other will fail.
  - However, if a user accidentally calls the API twice (e.g., double-clicks or retries due to a network issue) and the lock is released quickly, it is possible for two bookings to be created, each with a different idempotency key.
- **Best practice:** To fully prevent duplicate bookings, you should also check for an existing idempotency key at the start of `createBookingService`. This way, if the same request is retried, the backend will recognize it and not create a duplicate booking.

**Summary:**

- The current code prevents duplicate confirmations, but not duplicate initial bookings if the lock is released between requests.
- For full idempotency, add a check for the idempotency key at the start of `createBookingService`.

**Tip:**  
For Airbnb-like apps, locking by room or room category is usually better than locking the whole hotel.

---

## 11. What about unconfirmed bookings? How often should a cleanup job run, and is this needed in real-world apps like Agoda or MakeMyTrip?

**Answer:**

- In real-world systems, it's common for users to start a booking but not complete (confirm) it. This leaves behind unconfirmed ("pending") bookings and temporarily blocks rooms.
- To handle this, large platforms (like Agoda, MakeMyTrip, etc.) use a background job (cron/scheduler) that runs at regular intervals (e.g., every 5, 10, or 15 minutes) to:
  - Find bookings that are still pending and were created a certain time ago (e.g., 10-30 minutes).
  - Mark them as cancelled/expired and release the rooms for others to book.
- The exact frequency depends on business needs and user experience. Too frequent may disrupt slow users; too infrequent may block inventory for too long. 5-15 minutes is typical.
- Even with idempotency checks at the initial booking, this cleanup is needed because:
  - Users may abandon the process after starting.
  - Network issues or app crashes can leave bookings incomplete.
- This approach ensures rooms are not locked forever and inventory is efficiently managed.

**How do big companies do it?**

- Companies like Agoda, MakeMyTrip, and Airbnb use similar background cleanup jobs to expire or cancel unconfirmed bookings after a timeout.
- They may also send reminders to users to complete their booking before it expires.

**Summary:**

- Yes, a cron job or scheduler is required in real-world booking systems to handle unconfirmed bookings and keep inventory available for others.

---

## 12. Does the current room generation logic create a room for the end date as well?

**Answer:**

- Yes, in the current implementation, the `processDateBatch` function uses a loop with `while(currentDate <= endDate)`, which means it creates rooms for every date from `startDate` up to and including `endDate`.
- For example, if `startDate` is 7th and `endDate` is 8th, rooms will be created for both the 7th and the 8th.
- If you want to exclude the end date (so only up to the 7th in this example), you should change the loop to `while(currentDate < endDate)`.
- This is an important detail to keep in mind when setting up your date ranges for room generation.
